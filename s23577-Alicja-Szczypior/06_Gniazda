20210626
-----------------
06 GNIAZDA
-----------------

*łączność sieciowa - jak ją zaprogramować od zera, dwa komputery, żeby mogły się ze sobą komunikować i przekazywać między sobą jakieś dane

Ctrl C tells the terminal to send a SIGINT to the current foreground process, which by default translates into terminating the application. IT is an interrupt signal. It will stop the command.
Ctrl D tells the terminal that it should register a EOF on standard input, which bash interprets as a desire to exit. IT is end of file or exit(). When you entered CTRL+D , it exited from the command because of end of file.

Ctrl+D will not cause cat to terminate when the line is not in fact empty at the time. An interrupt generated by Ctrl+C will, though.

ANOTHER SIGNAL ctrl+\

SIGNAL FUNCTION! How to create a programm which is handling signals?

SIGNAL function is handling signals. It is like a go to! Jak skok! It doesnt matter in what part of code we are. It jumps to label from one loop to another loop.
	#include <signal.h>
	signal(number of signal, pointer to function)
	number of signal - we can type a constant, for example sigint - ctrl+C handles, int means interrupt, but it can be even number
	pointer to function - this function should run, when signal will be sent

FUNKCJA OBSLUGUJACA SYGNAL MA ZAWSZE TYP VOID I ARGUMENT TYPU INT.

CODE WITH COMMENTS HOW IT WORKS:
#include <stdio.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void registerHandler();
void signalHandler();

int main(){
    int x = 1;
    registerHandler();                  /*funkcja do obslugi sygnalu int*/

    while(x !=0){
        printf("Type 0 to finish.");
        fflush(stdout);                 /*is typically used for output stream only. Its purpose is to clear (or flush) the output buffer and move the buffered data to console (in case of stdout)*/
        scanf("%d", &x);                /*dopoki nie podamy 0 to bedzie sie powtarzac*/
    }
    return 0;
}

void signalHandler(int s){                  /*ta funkcja obsluguje sygnal*/ //ona jest wywolywana przez system operacyjny, NIEJAWNIE, 
    registerHandler();                      //wywolywana kiedy przyjedzie sygnal, przez system operacyjny, kiedy zarejestrujemy ja linia: 35!!!, tutaj tez jest ponowna rejestracja, tzn. kiedy jest sygnal w miejscu scanf (16) to on wykonuje skok do tej wlasnie funkcji. I jak sie wywola to ma wrocic normalne ustawienie ustandaryzowane przerwaniem. Dlatego potrzebna byla ponowna rejestracja. Samo signal tego nie wymaga.
    //ogolnie z tego miejsca, kiedy przyjdzie jakis inny sygnal mozna skoczyc gdzies jeszcze dalej i sigaction (36) umozliwia powrot tu z powrotem, ona blokuje to 
    printf("Handler triggered. s= %d", s);  /*FUNKCJA OBSLUGUJACA SYGNAL MUSI BYC TYPU VOID I PRZYJMOWAC ARGUMENT TYPU INT*/ //to wypisanie potwierdza ze ta funkcja sie uruchomila
}
void registerHandler(){                     //ona jest dodatkowa, zeby zarejestrowac przyjmowanie sygnalu, zeby bylo przejrzyscie, dla oddzielenia
    sigset_t iset;                          //flagi na to jakie sygnaly maja byc zablokowane
    struct sigaction act;

    sigemptyset(&iset);                     //ustawienie flag, czyli ktore sygnaly sa zablokowane a ktore zezwolone, tutaj zeruje wszystkie flagi (bo emptyset)

    act.sa_handler = &signalHandler;        //sa_handler stala zdefinowana w strukturze, przekazujemy adres do funkcji, ktora jest obsluga sygnalu zdefiniowanego w 36 (SIGINT)
    act.sa_mask = iset;                     //maska sygnalow ktore chemy miec zablokowane, dziala jak photoshop, jak jest ustawiona to sygnaly sa zablokowane
    act.sa_flags = 0;                       //jak jest 0 to zezwolone, jak 1 to zablokowane (podniesiona flaga)
    //ponizej jest funkcja, nie struktura, pierwsze to numer, to numer 2, ale przekazujemy stala, bo mozna, potem adres do struktury sigaction, a potem ustawiamy NULL, mozna doczytac
    sigaction(SIGINT, &act, NULL);          //rejestracja funkcji sygnalem int, ze struktura act, signal Handler obsluguje funkcje SIGINT!
    //funkcja signal podmienia domyslna funkcje obslugi programu (czyli przerwanie programu), ta obsluge mozna wylaczyc poprzez SIG_IGN - ignorowanie, podaje sie to stala jako nazwe funkcji tzn signal(SIGINT, SIG_IGN),
    //wowczas przy wciskaniu ctrl+C nic sie nie zadzieje

}

//FUNCKJA SAMA SIGNAL NIE WYMAGA PONOWNEJ REJESTRACJI. TUTAJ MAMY TROCHE INNA SYTUACJE.

RESULT:
bash-5.0$ ./z8Sygnaly
Type 0 to finish.3
Type 0 to finish.4
Type 0 to finish.0
bash-5.0$

#CTRL+C doesnt work
#CTRL+D it will work like in endless loop
#CTRL+\ will stop the programm

-------------------------------------------------------------------------
*obsluga blokowania sygnalu rozszerzona czesc
sigset_t getEmptySignalMask();
	sigset_t mask;
	sigEmptySet(&mask); 
	return mask;  ;to wszystko jest zwracane w main

w main:
	sigset_t signalMaskUSR1 = getEmptySignalMask();
	sigaddset(&signalMaskUsr1, SIGINT);
	... czyli kiety przyjdzie sygnalMaskUSR1 to w trakcie obslugi sygnalu mozemy wyslac sygnal INT ale nie bedzie kolejnego skoku,tylko SIGINT bedzie zablokowany, 
funkcja sigaddset - ustawiamy te sygnaly ktore maja byc zablokowane

funkcja pause(); ona czeka jak sleep

-------------------------------------------------------------------------
* HOW TO SEND PROGRAMMING SIGNAL?
KILL - command to send signals
int kill(pid_t pid, int sig); PID - what process, and what signal, we can type more than one pid :) 

IT iS TO SEND SIGNAL DYNAMICALLY AS PROGRAMIST FROM OUR PROGRAMM

#in man we have more than one site :) first site is basic

//excercise to make program wchich answer differently, oneTYPE a, doubletype b, again a ....
-------------------------------------------------------------------------
*GNIAZDA - SOCKETS

tutorial:

https://web.archive.org/web/20201107133926/https://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html

http://users.pja.edu.pl/~jms/qnx/help/tcpip_4.25_en/prog_guide/sock_advanced_tut.html

ls /var/run in LINUX

files with .socket or .sock extends - unix socket files, we can use it to make relation client server without using IPAdresses

SO WE HAVE: UNIX SOCKETS AND NETWORK SOCKETS (SIECIOWE)

-------------------------------------------------------------------------
*KOD SERWERA

ALL LINES FROM MAIN:
//first argument in socket programm should be number of port
	int portNo = atoi(argv[1]); these are numbers from 1 to 65535 it is 2^16
	//ports from 1 to 1024 - low ports, reserved for system, so only as a root we can reservet it
	//curl --vv https://www.wp.pl > /dev/null -running connection; 443 -(https-szyfrowane) port for encrypted connections, 80 (http) for unencrypted connections, we should be as root to use ports 1-1024!!!, 22 port for ssh
	//most ports are reserved for specific connection, and some are busy
	checkPortNo(portNo); checking if Port is in field of ports, its function
	//exit(2); it ends programm with code 2
//if everything is ok, then:
	startServer(portNo);
	return 0;

//netstat - command useful to see ports
//if program runs in port// this port is reserved(zawlaszczany), nothing can connect to the same port
//ONE PORT-ONE PROGRAM ON SERVER
//port na ktorym wystawia sie serwer musi byc znany
//port do ktorego sie laczymy jest losowy

IN STARTSERVER:
	//int cocketFileDescriptor, socketFileDescriptor - to tworzy socket -needed to start server listening on port
	//socklen_t clientAdressLength;
	//socket to wirtualne gniazdo, do ktorego lacza sie przychodzace polaczenia
	//gniazdo to nr IP:nr portu

		TWORZENIE SOCKETU!!!
		socket(TYP_POLACZENIA, TYP_POLACZENIA, 0 - czyli system sobie dobierze protokul na podstawie tego drugiego argumentu)
 
	socketFileDescriptor = socket(AF_INET, SOCK_STREAM, 0); - tworzenie socketu
	AF_INET - mowi o tym ze to socket internetowy

	SOCK_STREAM =TCP - argument typu połaczenia nawiazane i trzymaja polaczenie i zostala polaczona prawidlowo, jesli nie, to zostanie ponowiona, WOLNE, ALE PEWNE, uzywamy zeby miec pewnosc
	lub
	SOCK_DGRAM = UDP - nawiazanie polaczenia, ale jest CISZA, mniejszy narzut sieciowy, nie wymagaja odeslania odpowiedzi czy odebrano polaczenie, sa SZYBKIE, ALE NIEPEWNE, do wysylania duzej ilosci danych

	bind(socketFileSescriptor, (struct sockaddr *) & serw_addr, sizeof(serv_addr) - łączenie, przypisuje, ze od tego momentu socket jest przypisany do danego portu i port jest zawlaszczony dla danego programu
	//int acceptFileDescriptor //needed to accept connection which then produce file as a socket, pracuje w obrebie danego polaczenia dwukierunkowego, to polaczenie binarne
	//char buffer[256] - potrzebny do wysylania i odbierania danych z klienta
	+struktury do przechowywania danych klienta i serwera <netinet/in.h>

	//bzero do zerowania

	//serv_addr.sin_port = htons(portNo) - tu podajemy nr portu, ale nie sam, tylko w notacji sieciowej, mozna za pomoca funkcji htons (host to network shost) lub htonl (host to network long) ona konwertuje int do kolejnosci sieciowej

	int bindResult = bind(socketFileDescriptor, (struct sockaddr *) &serv_addr, sizeof(serv_addr)); -teraz dopiero to łączenie gniazda z adresem, port jest zwiazany z procesem, ktory utworzylismy, i nic sie juz nie polaczy

	//teraz mozemy zaczac sluchac
	listen(socketileDescriptor, 5) - 5 maksymalna ilosc polaczen czekajaca w kolejce, to maksimum dla wiekszosci serwerow
	//od tego momentu na ten port moze byc cos wyslane

	przeliczanie dlugosci adresu klienta ktory sie do nas podlaczy

	accept - do wywolania tej linijki nie pojdzie dalej, czyli do polaczenia, to jest funkcja blokujaca

	acceptFileDescriptor - juz po polaczeniu, ale z konkretnym klientem, inny klient to inny on, to juz jest to rzeczywiste polaczenie

	znowu zerowanie bufora, bzero(buffer, 256) 256 - tyle mozliwych znakow do odczytania

	program oczekuje ze klient cos wysle do serwera

	wysylanie i odczytywanie  wiadomosci:
	...

	close(acceptFileDescriptor) - zamykanie polaczenia z klientem
	close(socketFileDescriptor) - zamykamy serwer
	
-------------------------------------------------------------------------
*KOD KLIENTA

do programu przekazuje sie 3 argumentu,
pierwszy to adres IP serwera
drugi to numer portu, 	

sprawdzanie czy porty w odpowiednim przedziale

struktura klienta jest prostsza

	tak samo tworzenie socketu sieciowego

	server = gethostbyname(serverAddr) - system automatycznie rozwiaze ta nazwe, na nazwe uzywana przy polaczeniach, powinno sie uzywac funkcji getaffdrinfo

	zerowanie bufora, ustawianie parametrow struktury w jaki sposob powinno sie operowac na polaczeniu

	snprintf(NULL, 0, "%d", portNO) - funkcja zabezpiecza pewne rzeczy

	kazdy napis w jezyku c konczy sie na /0 !!!!!!

	znowu konwertujemy nr portu poprzez htons z int na network order

	strcpy - kopiuje ciagi znakow

	w serwerze bylo accept
	TUTAJ u klienta connect(socketFileDescriptor, (struct aockaddr *) &serv_addr, sizeof(serv_addr));

	sprawdzenie czy sie polaczylismy, czyscimy bufor, klient juz odczytuje, drukuje, przesyla, znowu ile znakow zostalo zapisanych do bufora 

	strlen - dlugosc bufora

	klient musi byc przygotowany na to, ze serwer cos do niego przesyla

	tutaj laczyly sie tylko z jednym serwerem biezacego hosta, wiec jest tylko socketFileDescriptor, serwer moze miec kilka klientow i in ma dlatego kilka acceptFileDescriptor

-------------------------------------------------------------------------
*DLACZEGO SYGNAlY?
Bo normalnie gdy robiony jest accept, to jest robiony fork dodatkowo, w tym momencie osobny proces obsluguje polaczenie przychodzace, a serwer dalej nasluchuje, dzieki temu serwer daje sobie rade, bo podproces obsluguje polaczenie robiace read, write, a parent czeka na kolejne przychodzace, i chcielibysmy kiedys wylaczyc, ale nie ctrl+c bo trzeba wszystko po kolei powylaczac, dlatego jest obsluga sygnalu, nie ma sie wylaczyc brutalnie, tylko musza sie zamykac

PLUS:
Jak ojciec dostaje sygnal pid, to wysyla je dzieciom, a jak dzieci dostana, to one juz tylko pozamykaja swoj acceptFileDescriptor, a SocketFileDescriptor wylaczy juz ojciec


